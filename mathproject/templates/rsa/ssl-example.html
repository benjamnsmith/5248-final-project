{% extends 'base.html' %}

{% block title %}
RSA EXAMPLE - SSL
{% endblock %}

{% block submenu %}
<div class="topper">
    <nav>
        <h3>RSA sub-topics</h3>
        <ul>
            <li><a href="{{ url_for('rsa.rsa') }}">RSA Overview</a></li>
            <li><a href="{{ url_for('rsa.sslExample') }}">RSA Example - SSL</a></li>
            <li><a href="{{ url_for('rsa.rsaAttack') }}">Attacking RSA</a></li>
        </ul>
    </nav>
</div>
{% endblock %}

{% block header %}
<h2>RSA EXAMPLE - SSL</h2>
<script src="{{ url_for('static', filename='ssl.js') }}" defer></script>
{% endblock %}


{% block content %}
<div class="field">
    <div id="col1" class="box">
        <p>
            SSL/TLS is how we encrypt data on the transport layer (OSI model) of network transfers.<br>
            We use RSA-based SSL/TLS certificates. <br>
            We can generate these certificates using a program called OpenSSL. 
        </p>
        <p>
            OpenSSL will generate real, valid RSA key pairs to be used in certifcate signing. <br>
            I made the keys as short as allowable, but it wouldn't let me make a key with less than 256 bits in the modulus
        </p>
        <p>
            Encryption: $m^e \pmod{n}$<br>
            Decryption: $c^d \pmod{n}$
        </p>
        <ol id="steps">
            <li>
                    <button id="priv-key">Generate SSL Keys (OpenSSL)</button>
            </li>
            <br>
            <li id="step2">
                <div>
                        <p>Ok, we've got our SSL keys, let's encrypt something. SSL is used to encrypt data across a network, so let's encrypt a website. 
                            More specifically, we'll encrypt an IP datagram packet. This is what really happens when you make a request for a website!
                        </p>
                        <p>
                            Here's an IP header I grabbed with Wireshark:
                        </p>
                        <span class="mono">
                            f8 4d 89 80 3c 36 0c 83 cc e2<br> 
                            30 bf 08 00 45 00 00 34 36 98<br>
                            40 00 <strong>39</strong> 06 ce 01 <strong>68 12 14 6b</strong><br> 
                            c0 a8
                            00 05 01 bb f1 e2 2f 61<br> d4 f9 44 05 a8 85 80 10
                            00 18<br> 30 c8 00 00 01 01 08 0a eb 90<br> ba 5e 71 c4
                            0c 7b 00 00 00 00<br> 00 00 00 00 00 00 00 00 00 00<br>
                            00 00 00 00

                            
                        </span>
                        <p>
                            OpenSSL will encrypt it for us, we can just run <span class="code">openssl rsautl -encrypt</span> with appropriate flags set for our key.
                            I set the server up to do this operation dynamically (it's already done it). If you refresh the page, you can generate new keys and encrypt this packet with those
                            keys to get a new ciphertext. Please don't generate too many keys, because I don't have a cleaning mechanism for them! 
                        </p>
                        <p>
                            The bolded solo number (0x39) is 57 in decimal. This is the time-to-live section of the IP header.
                            The bolded string of numbers is the source IP address. <strong>Fun activity</strong>: what website is this packet from?
                        </p>
                        <button id="trigger-3">Next step</button>
                </div>
            </li>
            <br>
            <li id="step3">
                <p>Here's our encrypted text:</p>
                <div id="ciphertext">
        
                </div>
            </li>
        </ol>
    </div>
    
    <div id="col2" class="box">
        <h3>SSL Key Components</h3>
        <table id="ssl-table">
            <tr>
                <th>Component</th>
                <th>Value</th>
            </tr>
        </table>
    </div>
</div>



{% endblock %}